// Generated by CoffeeScript 1.3.3
(function() {
  var app;

  app = angular.module("4real.directives", []);

  app.directive("clock", [
    "$filter", function($filter) {
      return {
        scope: true,
        link: function(scope, el, attr) {
          var timedUpdate, update;
          update = function() {
            var hour, minute, moment, now, obj, prefix, second;
            moment = window.moment;
            moment.lang(attr.language);
            prefix = $filter('prefix');
            now = moment().tz(attr.timezone);
            second = now.seconds() * 6;
            minute = now.minutes() * 6 + second / 60;
            hour = ((now.hours() % 12) / 12) * 360 + 90 + minute / 12;
            obj = {};
            obj[prefix.css + "transform"] = "rotate(" + hour + "deg)";
            angular.element(el[0].querySelector('#hour')).css(obj);
            obj[prefix.css + "transform"] = "rotate(" + minute + "deg)";
            angular.element(el[0].querySelector('#minute')).css(obj);
            obj[prefix.css + "transform"] = "rotate(" + second + "deg)";
            angular.element(el[0].querySelector('#second')).css(obj);
            scope.year = now.format('YYYY');
            scope.date = now.format('D');
            scope.day = now.format('ddd');
            scope.time = now.format('h:mm:ss');
            scope.month = now.format('MMM');
          };
          timedUpdate = function() {
            update();
            setTimeout(timedUpdate, 1000);
          };
          return timedUpdate();
        }
      };
    }
  ]);

  app.directive("about", [
    '$timeout', function($timeout) {
      return {
        link: function(scope, el, attr) {
          var appendLetter, cursor, lineIndex, newLine, position, printLine, text;
          lineIndex = 0;
          position = 0;
          text = "";
          cursor = "<span class='cursor'>|</span>";
          newLine = function() {
            text = "";
            if (scope.text[lineIndex]) {
              return printLine(scope.text[lineIndex]);
            }
          };
          printLine = function(line) {
            position = 0;
            return appendLetter(line, line[position]);
          };
          appendLetter = function(line, l) {
            text += line[position];
            el.html(text + cursor);
            position++;
            if (position < line.length) {
              return $timeout(function() {
                return appendLetter(line, line[position]);
              }, 40 + Math.random() * 20);
            } else {
              lineIndex++;
              return $timeout(function() {
                return newLine();
              }, 2000);
            }
          };
          return $timeout(newLine, 100);
        }
      };
    }
  ]);

  app.directive("glass", [
    '$window', '$timeout', '$filter', function($window, $timeout, $filter) {
      return {
        link: function(scope, el, att) {
          var prefix, resize;
          prefix = $filter('prefix');
          resize = function() {
            var obj, width;
            width = $window.innerWidth;
            if (el.hasClass('left')) {
              obj = {};
              obj[prefix.css + "transform"] = "translateX(" + width + "px) rotateY(90deg)";
              return el.css(obj);
            } else if (el.hasClass('right')) {
              obj = {};
              obj[prefix.css + "transform"] = "translateX(" + -width + "px) rotateY(-90deg)";
              return el.css(obj);
            } else if (el.hasClass('back')) {
              obj = {};
              obj[prefix.css + "transform"] = " translateZ(" + (-width) + "px) rotateY(-180deg)";
              return el.css(obj);
            }
          };
          resize();
          return angular.element($window).bind('resize', function() {
            return resize();
          });
        }
      };
    }
  ]);

  app.directive("cube", [
    '$document', '$window', '$timeout', '$location', function($document, $window, $timeout, $location) {
      return {
        link: function(scope, el, att) {
          var resize, rotateScene, scale, updateRotation, w;
          scope.oldH = 0;
          scope.oldV = 0;
          scope.newH = 0;
          scope.newV = 0;
          scope.oldR = 0;
          scope.newR = scope.rotate.y;
          scope.dragX = 0;
          rotateScene = function(e) {
            scope.newH = .5 - (e.pageX / $window.innerWidth);
            return scope.newV = -.5 + (e.pageY / $window.innerHeight);
          };
          updateRotation = function() {
            var dr, dx, dy, transform;
            dr = scope.rotate.y + scope.dragX - scope.oldR;
            if (Math.abs(dr) > .1) {
              dr *= .2;
            }
            scope.oldR += dr;
            dx = scope.newH - scope.oldH;
            dy = scope.newV - scope.oldV;
            if (Math.abs(dx) > .001) {
              dx *= .1;
            }
            if (Math.abs(dy) > .001) {
              dy *= .1;
            }
            scope.oldH += dx;
            scope.oldV += dy;
            transform = "translateZ(" + -scope.windowWidth / 2 + "px) rotateX(" + (scope.oldV * 5) + "deg) rotateY(" + ((scope.oldH * 5) + scope.oldR) + "deg) translateZ(" + scope.windowWidth / 2 + "px) ";
            el.css({
              "transform": transform,
              "-moz-transform": transform,
              "-ms-transform": transform,
              "-webkit-transform": transform
            });
            el.find("specular").css({
              "background-position": (-200 + (scope.oldH * -500)) + "px " + (-scope.oldV * 600 + 1000) + "px",
              opacity: 1 - (scope.oldH * .45) - (scope.oldV * .45)
            });
            transform = "rotateX(" + (65 + (scope.oldV * 20)) + "deg) rotateY(" + (10 - (scope.oldH * 20)) + "deg) skewX(-15deg)";
            el.find("shadow").css({
              "-webkit-transform": transform,
              "-moz-transform": transform,
              "-ms-transform": transform,
              "transform": transform
            });
            return $timeout(updateRotation, 30);
          };
          resize = function() {
            return scope.windowWidth = $window.innerWidth;
          };
          resize();
          $document.on('mousemove', rotateScene);
          scale = 180;
          w = angular.element($window);
          el.bind('pointerdown', function(e) {
            var startX, startY;
            startX = e.x;
            startY = e.y;
            return w.bind('pointermove', function(e) {
              e.maskedEvent.preventDefault();
              scope.dragX = ((e.x - startX) / scope.windowWidth) * scale;
              return e.maskedEvent.stopPropagation();
            });
          });
          w.bind('pointerup', function(e) {
            var angle;
            w.unbind('pointermove');
            scope.rotate.y += Math.round(scope.dragX / 90) * 90;
            scope.dragX = 0;
            angle = scope.rotate.y % 360;
            switch (angle) {
              case 0:
                scope.page = '';
                break;
              case 90:
                scope.page = 'charts';
                break;
              case -90:
                scope.page = 'projects';
                break;
              case 180:
                scope.page = 'about';
                break;
              case 270:
                scope.page = 'projects';
                break;
              case -270:
                scope.page = 'charts';
                break;
              case -180:
                scope.page = 'about';
            }
            return $location.path('/' + scope.page);
          });
          w.bind('resize', function() {
            return resize();
          });
          return updateRotation();
        }
      };
    }
  ]);

  app.directive("graph", [
    '$window', '$filter', function($window, $filter) {
      return {
        link: function(scope, el, att) {
          var data, gx, gy, height, line, margin, maximum, minimum, movingWindowAvg, parseDate, path, roll, svg, tooltip, updateChart, width, x, xAxis, y, yAxis;
          data = $filter('btcTrim')(scope.history, scope.trim);
          parseDate = d3.time.format("%b %Y").parse;
          margin = [30, 30, 50, 50];
          width = Math.max($window.innerWidth * .5, 300) - margin[1] - margin[3];
          height = Math.max($window.innerHeight * .5, 300) - margin[0] - margin[2];
          svg = d3.select("#chart").append("svg").attr("width", width + margin[3] + margin[1]).attr("height", height + margin[0] + margin[2]).append("svg:g").attr("transform", "translate(" + margin[3] + "," + margin[0] + ")");
          x = d3.time.scale().range([0, width]);
          y = d3.scale.linear().range([height, 0]);
          xAxis = d3.svg.axis().scale(x).orient("bottom").tickSize(3).tickPadding(3).ticks(5);
          yAxis = d3.svg.axis().scale(y).orient("left").tickSize(3).tickPadding(3).ticks(5).tickFormat(d3.format("$,f"));
          tooltip = d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);
          movingWindowAvg = function(arr, step) {
            return arr.map(function(_, idx) {
              var result, wnd;
              wnd = arr.slice(idx - step, idx + step + 1);
              result = d3.sum(wnd) / wnd.length;
              if (isNaN(result)) {
                result = _;
              }
              return result;
            });
          };
          line = function(data, k) {
            data = data.map(function(d, i) {
              if (i > k) {
                return [k, data[k]];
              } else {
                return [i, d];
              }
            });
            return d3.svg.line().x(function(d) {
              return x(d[1].date);
            }).y(function(d) {
              return y(d[1].price);
            })(data);
          };
          x.domain(d3.extent(data.map(function(d) {
            return d.date;
          })));
          maximum = d3.max(data.map(function(d) {
            return d.price;
          }));
          minimum = d3.min(data.map(function(d) {
            return d.price;
          }));
          y.domain([parseInt(minimum) - 5, parseInt(maximum) + 5]);
          roll = function(path, k) {
            if (k < data.length) {
              return path.transition().duration(1).ease("linear").attr("d", line(data, k)).each("end", function() {
                return roll(path, k + 1);
              });
            }
          };
          path = svg.append("path").attr("d", line(data, 0));
          roll(line, 0);
          gx = svg.append("svg:g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);
          gy = svg.append("svg:g").attr("class", "y axis").attr("transform", "translate(0,0)").call(yAxis);
          updateChart = function(redraw) {
            var circle;
            data = $filter('btcTrim')(scope.history, scope.trim);
            x.domain(d3.extent(data.map(function(d) {
              return d.date;
            })));
            maximum = d3.max(data.map(function(d) {
              return d.price;
            }));
            minimum = d3.min(data.map(function(d) {
              return d.price;
            }));
            y.domain([minimum - 5, maximum + 5]);
            gx.call(xAxis);
            gy.call(yAxis);
            if (redraw) {
              path.attr("d", line(data, 0)).transition();
              roll(path, 0);
            } else {
              path.datum(data).transition().attr("d", line(data, data.lenght));
            }
            circle = svg.selectAll("circle").data(data);
            circle.transition().attr("cx", function(d) {
              return x(d.date);
            }).attr("cy", function(d) {
              return y(d.price);
            });
            circle.enter().append("circle").attr("r", 3).attr("cx", function(d) {
              var cx;
              return cx = x(d.date);
            }).attr("cy", function(d) {
              return y(d.price);
            }).on("mouseover", function(d) {
              tooltip.transition().duration(200).style("opacity", 0.9);
              return tooltip.html('$' + d.price.toFixed(2)).style("left", (d3.event.pageX - 20) + "px").style("top", (d3.event.pageY - 28) + "px");
            }).on("mouseout", function(d) {
              return tooltip.transition().duration(500).style("opacity", 0);
            });
            return circle.exit().remove();
          };
          scope.$watch('history.length', function(newV, oldV) {
            var redraw;
            if (newV !== oldV) {
              redraw = false;
              if (Math.abs(newV - oldV) > 5) {
                redraw = true;
              }
              return updateChart(redraw);
            }
          });
          return scope.$watch('trim', function(newV, oldV) {
            if (newV !== oldV) {
              return updateChart();
            }
          });
        }
      };
    }
  ]);

  app.directive("water", [
    function() {
      return {
        link: function(scope, el, att) {}
      };
    }
  ]);

}).call(this);
